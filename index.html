<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Solar System - Select & Zoom</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,1);
        }
        #planet-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
            height: 30px;
        }
        #instructions {
            font-size: 12px;
            background: rgba(0, 0, 0, 0.4);
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="planet-name"></div>
    <div id="instructions">惑星をタップでズーム / 背景タップでリセット</div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    let virtualTime = 0;
    let isTouching = false;
    let lastTouchX = 0;
    let targetPlanet = null; // 現在追跡中の惑星

    const sunLight = new THREE.PointLight(0xffffff, 5, 1500, 0);
    scene.add(sunLight);
    scene.add(new THREE.AmbientLight(0x404040, 1.5));

    const planetData = [
        { name: "水星", color: 0xA5A5A5, distance: 45,  size: 1.5, period: 0.24 },
        { name: "金星", color: 0xE3BB76, distance: 70,  size: 2.5, period: 0.61 },
        { name: "地球", color: 0x2271B3, distance: 100, size: 2.8, period: 1.0 },
        { name: "火星", color: 0xE27B58, distance: 130, size: 2.0, period: 1.88 },
        { name: "木星", color: 0xD39C7E, distance: 190, size: 7.0, period: 11.86 },
        { name: "土星", color: 0xC5AB6E, distance: 250, size: 6.0, period: 29.46 },
        { name: "天王星", color: 0xBBE1E4, distance: 310, size: 4.0, period: 84.01 },
        { name: "海王星", color: 0x6081FF, distance: 370, size: 4.0, period: 164.8 }
    ];

    const sun = new THREE.Mesh(
        new THREE.SphereGeometry(18, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xFFCC00 })
    );
    sun.userData = { name: "太陽" };
    scene.add(sun);

    const planets = [];
    planetData.forEach(data => {
        const orbit = new THREE.Mesh(
            new THREE.RingGeometry(data.distance - 0.4, data.distance + 0.4, 128),
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.1 })
        );
        orbit.rotation.x = Math.PI / 2;
        scene.add(orbit);

        const group = new THREE.Group();
        const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(data.size, 32, 32),
            new THREE.MeshStandardMaterial({ color: data.color })
        );
        mesh.position.x = data.distance;
        mesh.userData = { name: data.name, size: data.size }; // データ保持
        
        group.add(mesh);
        scene.add(group);
        planets.push({ mesh, group, period: data.period });
    });

    // 背景
    const starGeo = new THREE.BufferGeometry();
    const starCoords = [];
    for(let i=0; i<3000; i++) starCoords.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
    scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 1, color: 0xffffff })));

    camera.position.set(0, 250, 500);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- タップ判定 (Raycaster) ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onSelect(x, y) {
        mouse.x = (x / window.innerWidth) * 2 - 1;
        mouse.y = -(y / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        const planetMatch = intersects.find(i => i.object.userData.name);
        
        if (planetMatch) {
            targetPlanet = planetMatch.object;
            document.getElementById('planet-name').innerText = targetPlanet.userData.name;
        } else {
            targetPlanet = null;
            document.getElementById('planet-name').innerText = "";
            // リセット時は中心を見る
            controls.target.set(0, 0, 0);
        }
    }

    // イベント登録
    window.addEventListener('touchstart', (e) => {
        if(e.touches.length === 1) {
            isTouching = true;
            lastTouchX = e.touches[0].clientX;
            onSelect(e.touches[0].clientX, e.touches[0].clientY);
        }
    });

    window.addEventListener('mousedown', (e) => {
        isTouching = true;
        lastTouchX = e.clientX;
        onSelect(e.clientX, e.clientY);
    });

    window.addEventListener('touchmove', (e) => {
        if (isTouching && e.touches.length === 1) {
            const deltaX = e.touches[0].clientX - lastTouchX;
            virtualTime += deltaX * 0.01;
            lastTouchX = e.touches[0].clientX;
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (isTouching) {
            virtualTime += (e.clientX - lastTouchX) * 0.01;
            lastTouchX = e.clientX;
        }
    });

    window.addEventListener('mouseup', () => isTouching = false);
    window.addEventListener('touchend', () => isTouching = false);

    // --- ループ ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (!isTouching) virtualTime += 0.005;

        planets.forEach(p => {
            p.group.rotation.y = virtualTime / p.period;
        });

        if (targetPlanet) {
            // ターゲットとなる惑星の世界座標を取得
            const worldPos = new THREE.Vector3();
            targetPlanet.getWorldPosition(worldPos);
            
            // カメラの注視点を惑星に滑らかに合わせる
            controls.target.lerp(worldPos, 0.1);

            // ズーム距離の調整（惑星の大きさに合わせる）
            const idealDist = targetPlanet.userData.size ? targetPlanet.userData.size * 5 + 10 : 50;
            // 現在のカメラ位置と惑星の距離を詰める（任意で追加可能）
        }

        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
